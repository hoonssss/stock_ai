print("KRX 고급 백테스팅 분석기 - XGBoost + 앙상블 + 실제 성과 검증")
print("실제 투자 성과를 통한 모델 검증 및 고정밀 예측 시스템")
print("="*80)

# ================================================================
# 라이브러리 설치 및 임포트
# ================================================================

import subprocess
import sys
import warnings
warnings.filterwarnings('ignore')

def install_and_import(package, import_name=None):
    """패키지 설치 및 임포트"""
    if import_name is None:
        import_name = package.split('==')[0].replace('-', '_')

    try:
        __import__(import_name)
        return True
    except ImportError:
        print(f"설치 중: {package}")
        try:
            subprocess.check_call([sys.executable, '-m', 'pip', 'install', '--quiet', package])
            return True
        except:
            try:
                subprocess.check_call([sys.executable, '-m', 'pip', 'install', '--force-reinstall', '--no-deps', '--quiet', package])
                return True
            except:
                print(f"설치 실패: {package}")
                return False

print("필수 라이브러리 설치 중...")

# 핵심 ML 라이브러리 (호환성 개선)
essential_packages = [
    ('pandas==2.0.3', 'pandas'),
    ('numpy==1.21.6', 'numpy'),  # numpy 버전 다운그레이드로 호환성 해결
    ('yfinance==0.2.18', 'yfinance'),
    ('requests==2.31.0', 'requests'),
    ('scikit-learn==1.3.0', 'sklearn'),
    ('lightgbm==3.3.5', 'lightgbm'),
    ('xgboost==1.7.5', 'xgboost'),  # XGBoost 추가
    ('tqdm', 'tqdm'),
    ('optuna==3.2.0', 'optuna'),    # 하이퍼파라미터 최적화
]

# CatBoost는 선택적 설치 (호환성 문제 방지)
try:
    print("CatBoost 호환성 테스트 중...")
    import catboost as cb
    print("CatBoost 사용 가능")
    HAS_CATBOOST = True
except:
    print("CatBoost 스킵 - XGBoost + LightGBM + RandomForest 사용")
    HAS_CATBOOST = False

for package, import_name in essential_packages:
    install_and_import(package, import_name)

# CatBoost 별도 처리 (호환성 문제 해결)
print("CatBoost 호환성 확인...")
try:
    import catboost as cb
    print("CatBoost 사용 가능")
    HAS_CATBOOST = True
except Exception as e:
    print(f"CatBoost 사용 불가: {e}")
    print("XGBoost + LightGBM + RandomForest 앙상블로 진행")
    HAS_CATBOOST = False

# pandas_ta 설치
try:
    print("pandas_ta 설치 시도...")
    subprocess.check_call([sys.executable, '-m', 'pip', 'install', '--quiet', 'pandas_ta==0.3.14b0'])
    import pandas_ta as ta
    print("pandas_ta 설치 성공!")
    USE_PANDAS_TA = True
except:
    print("pandas_ta 설치 실패 - 내장 지표 사용")
    USE_PANDAS_TA = False

print("라이브러리 설치 완료!")

# ================================================================
# 고급 KRX 백테스팅 분석기
# ================================================================

import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import time
import gc
import requests
import os
import yfinance as yf
from concurrent.futures import ThreadPoolExecutor, as_completed
from threading import Lock
import multiprocessing as mp
from tqdm import tqdm

# ML 라이브러리
from sklearn.ensemble import RandomForestClassifier, VotingClassifier, GradientBoostingClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, classification_report
from sklearn.preprocessing import StandardScaler, RobustScaler
from sklearn.model_selection import TimeSeriesSplit, cross_val_score
import lightgbm as lgb
import xgboost as xgb

try:
    import catboost as cb
    HAS_CATBOOST = True
except:
    HAS_CATBOOST = False

try:
    import optuna
    HAS_OPTUNA = True
except:
    HAS_OPTUNA = False

class AdvancedKRXBacktester:
    """고급 KRX 백테스팅 분석기 - 실제 성과 검증"""

    def __init__(self):
        self.market_data = {}
        self.krx_stocks = []
        self.results_cache = []
        self.failed_downloads = set()
        self.successful_downloads = set()
        self.lock = Lock()
        self.cpu_count = mp.cpu_count()
        
        # 백테스팅 설정
        self.initial_capital = 10000000  # 1천만원
        self.commission_rate = 0.00315   # 거래수수료 0.315%
        self.tax_rate = 0.0025          # 거래세 0.25%
        self.slippage_rate = 0.001      # 슬리피지 0.1%
        
        # 모델 설정
        self.models = {}
        self.ensemble_weights = {}
        self.feature_importance = {}
        
        self.setup_system()

    def setup_system(self):
        """시스템 설정"""
        print("KRX 고급 백테스팅 시스템 설정 중...")
        self.ensure_save_directory()
        self.initialize_market_data()
        self.load_krx_stocks()
        print(f"CPU 코어: {self.cpu_count}개")
        print(f"KRX 종목: {len(self.krx_stocks):,}개")
        print("XGBoost + LightGBM + RandomForest 앙상블 모드" + (" + CatBoost" if HAS_CATBOOST else ""))

    def ensure_save_directory(self):
        """저장 디렉토리 설정"""
        try:
            if os.path.exists('/content/'):
                self.save_dir = '/content/'
            else:
                self.save_dir = './'
            
            test_file = os.path.join(self.save_dir, 'test_write.txt')
            try:
                with open(test_file, 'w') as f:
                    f.write('test')
                os.remove(test_file)
                print("디렉토리 쓰기 권한 확인")
            except:
                self.save_dir = './'
        except Exception as e:
            print(f"디렉토리 설정 오류: {e}")
            self.save_dir = './'

    def initialize_market_data(self):
        """KOSPI/KOSDAQ/KRW/USD 등 시장 데이터 초기화"""
        try:
            print("시장 지수 데이터 다운로드 중...")
            
            # KOSPI
            kospi = yf.Ticker("^KS11")
            kospi_data = kospi.history(period="3y")
            if len(kospi_data) > 0:
                kospi_data.reset_index(inplace=True)
                kospi_data['Date'] = pd.to_datetime(kospi_data['Date']).dt.tz_localize(None)
                kospi_data['KOSPI_Close'] = kospi_data['Close']
                kospi_data['KOSPI_Return'] = kospi_data['Close'].pct_change()
                kospi_data['KOSPI_Volatility'] = kospi_data['KOSPI_Return'].rolling(20).std()
                self.market_data['kospi'] = kospi_data[['Date', 'KOSPI_Close', 'KOSPI_Return', 'KOSPI_Volatility']]
                print(f"KOSPI 데이터: {len(kospi_data)}일")
            
            # KOSDAQ
            try:
                kosdaq = yf.Ticker("^KQ11")
                kosdaq_data = kosdaq.history(period="3y")
                if len(kosdaq_data) > 0:
                    kosdaq_data.reset_index(inplace=True)
                    kosdaq_data['Date'] = pd.to_datetime(kosdaq_data['Date']).dt.tz_localize(None)
                    kosdaq_data['KOSDAQ_Close'] = kosdaq_data['Close']
                    kosdaq_data['KOSDAQ_Return'] = kosdaq_data['Close'].pct_change()
                    self.market_data['kosdaq'] = kosdaq_data[['Date', 'KOSDAQ_Close', 'KOSDAQ_Return']]
                    print(f"KOSDAQ 데이터: {len(kosdaq_data)}일")
            except:
                pass
                
            # 달러원 환율
            try:
                usdkrw = yf.Ticker("USDKRW=X")
                usd_data = usdkrw.history(period="3y")
                if len(usd_data) > 0:
                    usd_data.reset_index(inplace=True)
                    usd_data['Date'] = pd.to_datetime(usd_data['Date']).dt.tz_localize(None)
                    usd_data['USD_KRW'] = usd_data['Close']
                    usd_data['USD_Return'] = usd_data['Close'].pct_change()
                    self.market_data['usdkrw'] = usd_data[['Date', 'USD_KRW', 'USD_Return']]
                    print(f"USD/KRW 데이터: {len(usd_data)}일")
            except:
                pass

        except Exception as e:
            print(f"시장 데이터 로드 실패: {e}")
            # 백업 데이터 생성
            dates = pd.date_range(start='2022-01-01', end='2024-12-31', freq='D')
            kospi_prices = 2500 + np.random.randn(len(dates)).cumsum() * 10
            self.market_data['kospi'] = pd.DataFrame({
                'Date': dates,
                'KOSPI_Close': kospi_prices,
                'KOSPI_Return': np.concatenate([[0], np.diff(kospi_prices) / kospi_prices[:-1]]),
                'KOSPI_Volatility': np.random.uniform(0.01, 0.03, len(dates))
            })
            print("백업 KOSPI 데이터 생성 완료")

    def load_krx_stocks(self):
        """KRX 종목 리스트 로드"""
        try:
            print("KRX 종목 리스트 수집 중...")
            all_stocks = []

            # KRX 공식 사이트
            try:
                print("KRX 공식 사이트에서 종목 다운로드...")
                url = 'http://kind.krx.co.kr/corpgeneral/corpList.do?method=download&searchType=13'
                
                for encoding in ['euc-kr', 'cp949', 'utf-8']:
                    try:
                        df_list = pd.read_html(url, header=0, encoding=encoding)
                        krx_df = df_list[0]
                        
                        if '종목코드' in krx_df.columns and '회사명' in krx_df.columns:
                            krx_df = krx_df[['종목코드', '회사명']].copy()
                            krx_df['종목코드'] = krx_df['종목코드'].astype(str).str.zfill(6)
                            krx_df.columns = ['code', 'company']
                            krx_df = krx_df.drop_duplicates('code')
                            
                            krx_stocks = [(row['code'], row['company']) for _, row in krx_df.iterrows()]
                            all_stocks.extend(krx_stocks)
                            
                            print(f"KRX 공식: {len(krx_stocks)}개 종목 수집")
                            break
                    except Exception as e:
                        continue
            except Exception as e:
                print(f"KRX 공식 사이트 접속 실패: {e}")

            # 백업: 주요 종목 하드코딩
            if len(all_stocks) < 100:
                print("주요 종목 하드코딩 백업...")
                major_stocks = [
                    ('005930', '삼성전자'), ('000660', 'SK하이닉스'), ('035420', 'NAVER'),
                    ('005380', '현대차'), ('051910', 'LG화학'), ('006400', '삼성SDI'),
                    ('035720', '카카오'), ('028260', '삼성물산'), ('068270', '셀트리온'),
                    ('207940', '삼성바이오로직스'), ('000270', '기아'), ('105560', 'KB금융'),
                    ('055550', '신한지주'), ('086790', '하나금융지주'), ('012330', '현대모비스'),
                    ('003670', '포스코홀딩스'), ('096770', 'SK이노베이션'), ('030200', 'KT'),
                    ('017670', 'SK텔레콤'), ('036570', '엔씨소프트'), ('003550', 'LG'),
                    ('000810', '삼성화재'), ('015760', '한국전력'), ('009150', '삼성전기'),
                    ('090430', '아모레퍼시픽'), ('011170', '롯데케미칼'), ('032830', '삼성생명'),
                ]
                all_stocks.extend(major_stocks)
                print(f"주요 종목 하드코딩: {len(major_stocks)}개 추가")

            # 중복 제거 및 정렬
            all_stocks = list(set(all_stocks))
            all_stocks.sort(key=lambda x: x[0])
            self.krx_stocks = all_stocks

            print(f"최종 KRX 종목: {len(self.krx_stocks):,}개")

        except Exception as e:
            print(f"종목 리스트 수집 실패: {e}")
            self.krx_stocks = [('005930', '삼성전자'), ('000660', 'SK하이닉스'), ('035420', 'NAVER')]
            print(f"기본 종목으로 대체: {len(self.krx_stocks)}개")

    def download_stock_data(self, code, company, max_retries=2):
        """주가 데이터 다운로드 (3년치)"""
        if code in self.failed_downloads:
            return None
        if code in self.successful_downloads:
            return None

        for attempt in range(max_retries):
            try:
                # yfinance 시도
                for suffix in ['.KS', '.KQ', '']:
                    try:
                        ticker_symbol = f"{code}{suffix}"
                        ticker = yf.Ticker(ticker_symbol)
                        df = ticker.history(period="3y", auto_adjust=True, repair=True)  # 3년치

                        if len(df) >= 200:  # 최소 200일 데이터
                            df.reset_index(inplace=True)
                            df['Date'] = pd.to_datetime(df['Date']).dt.tz_localize(None)

                            required_cols = ['Date', 'Open', 'High', 'Low', 'Close', 'Volume']
                            if all(col in df.columns for col in required_cols):
                                df = df.dropna(subset=['Close'])
                                df = df[df['Close'] > 0]
                                df = df[df['Volume'] >= 0]

                                if len(df) >= 200:
                                    self.successful_downloads.add(code)
                                    return df[required_cols]
                    except:
                        continue

                time.sleep(0.1)

            except Exception as e:
                if attempt == max_retries - 1:
                    self.failed_downloads.add(code)
                continue

        return None

    def calculate_advanced_features(self, df):
        """고급 기술적 지표 생성 (예측률 극대화)"""
        try:
            # 기본 수익률
            df['Return'] = df['Close'].pct_change()
            df['Return_3d'] = df['Close'].pct_change(3)
            df['Return_5d'] = df['Close'].pct_change(5)
            df['Return_10d'] = df['Close'].pct_change(10)
            df['Return_20d'] = df['Close'].pct_change(20)

            # 다양한 이동평균
            for period in [5, 10, 20, 50, 100, 200]:
                if len(df) > period:
                    df[f'MA_{period}'] = df['Close'].rolling(period).mean()
                    df[f'MA_Ratio_{period}'] = df['Close'] / (df[f'MA_{period}'] + 1e-10)

            # 지수이동평균
            for period in [12, 26, 50]:
                df[f'EMA_{period}'] = df['Close'].ewm(span=period).mean()
                df[f'EMA_Ratio_{period}'] = df['Close'] / (df[f'EMA_{period}'] + 1e-10)

            # RSI (다양한 기간)
            for period in [14, 21, 30]:
                df[f'RSI_{period}'] = self.calculate_rsi(df['Close'], period)

            # MACD (다양한 설정)
            df['MACD_12_26'], df['MACD_Signal_12_26'] = self.calculate_macd(df['Close'], 12, 26, 9)
            df['MACD_Histogram'] = df['MACD_12_26'] - df['MACD_Signal_12_26']
            
            # 볼린저 밴드 (다양한 기간)
            for period in [20, 50]:
                bb_middle = df['Close'].rolling(period).mean()
                bb_std = df['Close'].rolling(period).std()
                df[f'BB_Upper_{period}'] = bb_middle + (bb_std * 2)
                df[f'BB_Lower_{period}'] = bb_middle - (bb_std * 2)
                df[f'BB_Position_{period}'] = (df['Close'] - df[f'BB_Lower_{period}']) / (df[f'BB_Upper_{period}'] - df[f'BB_Lower_{period}'] + 1e-10)
                df[f'BB_Width_{period}'] = (df[f'BB_Upper_{period}'] - df[f'BB_Lower_{period}']) / bb_middle

            # 스토캐스틱
            df['Stoch_K'], df['Stoch_D'] = self.calculate_stochastic(df)

            # Williams %R
            df['Williams_R'] = self.calculate_williams_r(df)

            # CCI (Commodity Channel Index)
            df['CCI'] = self.calculate_cci(df)

            # 거래량 지표
            for period in [5, 10, 20]:
                df[f'Volume_MA_{period}'] = df['Volume'].rolling(period).mean()
                df[f'Volume_Ratio_{period}'] = df['Volume'] / (df[f'Volume_MA_{period}'] + 1e-10)

            # OBV (On Balance Volume)
            df['OBV'] = self.calculate_obv(df)

            # 변동성 지표
            for period in [5, 10, 20]:
                df[f'Volatility_{period}'] = df['Return'].rolling(period).std()
                df[f'ATR_{period}'] = self.calculate_atr(df, period)

            # 가격 패턴
            df['High_Low_Ratio'] = df['High'] / (df['Low'] + 1e-10)
            df['Open_Close_Ratio'] = df['Open'] / (df['Close'] + 1e-10)
            df['Price_Range'] = (df['High'] - df['Low']) / (df['Close'] + 1e-10)

            # 시장 대비 성과
            if 'kospi' in self.market_data:
                kospi_data = self.market_data['kospi']
                df_merged = pd.merge(df, kospi_data, on='Date', how='left')
                df_merged['KOSPI_Return'] = df_merged['KOSPI_Return'].fillna(0)
                df_merged['Beta'] = df_merged['Return'].rolling(60).corr(df_merged['KOSPI_Return'])
                df_merged['Alpha'] = df_merged['Return'] - df_merged['KOSPI_Return']
                df = df_merged.drop(['KOSPI_Close', 'KOSPI_Volatility'], axis=1, errors='ignore')

            # 고급 모멘텀 스코어
            momentum_factors = []
            for col in df.columns:
                if 'RSI' in col:
                    momentum_factors.append((df[col] > 50).astype(int))
                elif 'MACD_Histogram' in col:
                    momentum_factors.append((df[col] > 0).astype(int))
                elif 'MA_Ratio' in col and '20' in col:
                    momentum_factors.append((df[col] > 1).astype(int))

            if momentum_factors:
                df['Momentum_Score'] = sum(momentum_factors) / len(momentum_factors)
            else:
                df['Momentum_Score'] = 0.5

            # 타겟 변수들 (다양한 기간과 수익률)
            for days in [1, 3, 5, 7]:
                for return_threshold in [0.02, 0.03, 0.05]:
                    future_return = df['Close'].shift(-days) / df['Close'] - 1
                    df[f'Target_{days}d_{int(return_threshold*100)}pct'] = (future_return > return_threshold).astype(int)

            # 기본 타겟 (3일 후 3% 상승)
            future_return = df['Close'].shift(-3) / df['Close'] - 1
            df['Target'] = (future_return > 0.03).astype(int)

            # NaN 처리
            numeric_columns = df.select_dtypes(include=[np.number]).columns
            df[numeric_columns] = df[numeric_columns].fillna(method='ffill').fillna(0)
            df = df.replace([np.inf, -np.inf], 0)

            return df

        except Exception as e:
            print(f"기술적 지표 계산 오류: {e}")
            return None

    def calculate_rsi(self, prices, period=14):
        """RSI 계산"""
        try:
            delta = prices.diff()
            gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
            rs = gain / (loss + 1e-10)
            rsi = 100 - (100 / (1 + rs))
            return rsi
        except:
            return pd.Series([50] * len(prices), index=prices.index)

    def calculate_macd(self, prices, fast=12, slow=26, signal=9):
        """MACD 계산"""
        try:
            exp1 = prices.ewm(span=fast).mean()
            exp2 = prices.ewm(span=slow).mean()
            macd = exp1 - exp2
            macd_signal = macd.ewm(span=signal).mean()
            return macd, macd_signal
        except:
            return pd.Series([0] * len(prices), index=prices.index), pd.Series([0] * len(prices), index=prices.index)

    def calculate_stochastic(self, df, k_period=14, d_period=3):
        """스토캐스틱 계산"""
        try:
            low_min = df['Low'].rolling(window=k_period).min()
            high_max = df['High'].rolling(window=k_period).max()
            k_percent = 100 * ((df['Close'] - low_min) / (high_max - low_min + 1e-10))
            d_percent = k_percent.rolling(window=d_period).mean()
            return k_percent, d_percent
        except:
            return pd.Series([50] * len(df), index=df.index), pd.Series([50] * len(df), index=df.index)

    def calculate_williams_r(self, df, period=14):
        """Williams %R 계산"""
        try:
            high_max = df['High'].rolling(window=period).max()
            low_min = df['Low'].rolling(window=period).min()
            williams_r = -100 * ((high_max - df['Close']) / (high_max - low_min + 1e-10))
            return williams_r
        except:
            return pd.Series([-50] * len(df), index=df.index)

    def calculate_cci(self, df, period=20):
        """CCI 계산"""
        try:
            tp = (df['High'] + df['Low'] + df['Close']) / 3
            ma = tp.rolling(window=period).mean()
            md = tp.rolling(window=period).apply(lambda x: np.mean(np.abs(x - x.mean())))
            cci = (tp - ma) / (0.015 * md + 1e-10)
            return cci
        except:
            return pd.Series([0] * len(df), index=df.index)

    def calculate_obv(self, df):
        """OBV 계산"""
        try:
            obv = [0]
            for i in range(1, len(df)):
                if df['Close'].iloc[i] > df['Close'].iloc[i-1]:
                    obv.append(obv[-1] + df['Volume'].iloc[i])
                elif df['Close'].iloc[i] < df['Close'].iloc[i-1]:
                    obv.append(obv[-1] - df['Volume'].iloc[i])
                else:
                    obv.append(obv[-1])
            return pd.Series(obv, index=df.index)
        except:
            return pd.Series([0] * len(df), index=df.index)

    def calculate_atr(self, df, period=14):
        """ATR 계산"""
        try:
            high_low = df['High'] - df['Low']
            high_close = np.abs(df['High'] - df['Close'].shift())
            low_close = np.abs(df['Low'] - df['Close'].shift())
            ranges = pd.concat([high_low, high_close, low_close], axis=1)
            true_range = np.max(ranges, axis=1)
            atr = true_range.rolling(window=period).mean()
            return atr
        except:
            return pd.Series([0] * len(df), index=df.index)

    def optimize_hyperparameters(self, X_train, y_train, model_type='xgboost'):
        """Optuna를 사용한 하이퍼파라미터 최적화"""
        if not HAS_OPTUNA:
            return self.get_default_params(model_type)

        def objective(trial):
            if model_type == 'xgboost':
                params = {
                    'n_estimators': trial.suggest_int('n_estimators', 100, 1000),
                    'max_depth': trial.suggest_int('max_depth', 3, 10),
                    'learning_rate': trial.suggest_float('learning_rate', 0.01, 0.3),
                    'subsample': trial.suggest_float('subsample', 0.6, 1.0),
                    'colsample_bytree': trial.suggest_float('colsample_bytree', 0.6, 1.0),
                    'reg_alpha': trial.suggest_float('reg_alpha', 0, 10),
                    'reg_lambda': trial.suggest_float('reg_lambda', 0, 10),
                }
                model = xgb.XGBClassifier(**params, random_state=42, n_jobs=1, verbosity=0)
            elif model_type == 'lightgbm':
                params = {
                    'n_estimators': trial.suggest_int('n_estimators', 100, 1000),
                    'num_leaves': trial.suggest_int('num_leaves', 20, 300),
                    'learning_rate': trial.suggest_float('learning_rate', 0.01, 0.3),
                    'feature_fraction': trial.suggest_float('feature_fraction', 0.6, 1.0),
                    'bagging_fraction': trial.suggest_float('bagging_fraction', 0.6, 1.0),
                    'reg_alpha': trial.suggest_float('reg_alpha', 0, 10),
                    'reg_lambda': trial.suggest_float('reg_lambda', 0, 10),
                }
                model = lgb.LGBMClassifier(**params, random_state=42, n_jobs=1, verbose=-1)

            # 시계열 교차검증
            tscv = TimeSeriesSplit(n_splits=3)
            scores = cross_val_score(model, X_train, y_train, cv=tscv, scoring='f1')
            return scores.mean()

        try:
            study = optuna.create_study(direction='maximize', pruner=optuna.pruners.MedianPruner())
            study.optimize(objective, n_trials=10, timeout=120)  # 10회 시행, 2분 제한
            return study.best_params
        except:
            return self.get_default_params(model_type)

    def get_default_params(self, model_type):
        """기본 하이퍼파라미터"""
        if model_type == 'xgboost':
            return {
                'n_estimators': 300,
                'max_depth': 6,
                'learning_rate': 0.1,
                'subsample': 0.8,
                'colsample_bytree': 0.8,
                'reg_alpha': 1,
                'reg_lambda': 1,
            }
        elif model_type == 'lightgbm':
            return {
                'n_estimators': 300,
                'num_leaves': 50,
                'learning_rate': 0.1,
                'feature_fraction': 0.8,
                'bagging_fraction': 0.8,
                'reg_alpha': 1,
                'reg_lambda': 1,
            }

    def train_ensemble_models(self, df):
        """앙상블 모델 훈련 (XGBoost + LightGBM + CatBoost + RandomForest)"""
        try:
            # 피처 선택
            feature_columns = []
            for col in df.columns:
                if col not in ['Date', 'Target'] and not col.startswith('Target_') and pd.api.types.is_numeric_dtype(df[col]):
                    feature_columns.append(col)

            if len(feature_columns) < 10:
                return None, None, 0.5

            X = df[feature_columns].iloc[:-10]  # 마지막 10일 제외 (미래 데이터 방지)
            y = df['Target'].iloc[:-10]

            if len(X) < 100 or y.sum() < 10:
                return None, None, 0.5

            # 시계열 분할 (백테스팅용)
            split_ratio = 0.7
            split_idx = int(len(X) * split_ratio)
            
            X_train, X_test = X[:split_idx], X[split_idx:]
            y_train, y_test = y[:split_idx], y[split_idx:]

            # 스케일링
            scaler = RobustScaler()
            X_train_scaled = scaler.fit_transform(X_train)
            X_test_scaled = scaler.transform(X_test)

            models = {}
            model_scores = {}

            # 1. XGBoost (최적화됨)
            print("XGBoost 훈련 중...")
            xgb_params = self.optimize_hyperparameters(X_train_scaled, y_train, 'xgboost')
            xgb_model = xgb.XGBClassifier(**xgb_params, random_state=42, n_jobs=1, verbosity=0)
            xgb_model.fit(X_train_scaled, y_train)
            xgb_pred = xgb_model.predict(X_test_scaled)
            xgb_score = f1_score(y_test, xgb_pred)
            models['xgboost'] = xgb_model
            model_scores['xgboost'] = xgb_score

            # 2. LightGBM (최적화됨)
            print("LightGBM 훈련 중...")
            lgb_params = self.optimize_hyperparameters(X_train_scaled, y_train, 'lightgbm')
            lgb_model = lgb.LGBMClassifier(**lgb_params, random_state=42, n_jobs=1, verbose=-1)
            lgb_model.fit(X_train_scaled, y_train)
            lgb_pred = lgb_model.predict(X_test_scaled)
            lgb_score = f1_score(y_test, lgb_pred)
            models['lightgbm'] = lgb_model
            model_scores['lightgbm'] = lgb_score

            # 3. CatBoost
            if HAS_CATBOOST:
                print("CatBoost 훈련 중...")
                cb_model = cb.CatBoostClassifier(
                    iterations=200,
                    depth=6,
                    learning_rate=0.1,
                    random_seed=42,
                    verbose=False
                )
                cb_model.fit(X_train_scaled, y_train)
                cb_pred = cb_model.predict(X_test_scaled)
                cb_score = f1_score(y_test, cb_pred)
                models['catboost'] = cb_model
                model_scores['catboost'] = cb_score

            # 4. Random Forest
            print("Random Forest 훈련 중...")
            rf_model = RandomForestClassifier(
                n_estimators=200,
                max_depth=10,
                min_samples_split=5,
                min_samples_leaf=2,
                random_state=42,
                n_jobs=1
            )
            rf_model.fit(X_train_scaled, y_train)
            rf_pred = rf_model.predict(X_test_scaled)
            rf_score = f1_score(y_test, rf_pred)
            models['randomforest'] = rf_model
            model_scores['randomforest'] = rf_score

            # 5. Gradient Boosting
            print("Gradient Boosting 훈련 중...")
            gb_model = GradientBoostingClassifier(
                n_estimators=200,
                learning_rate=0.1,
                max_depth=6,
                random_state=42
            )
            gb_model.fit(X_train_scaled, y_train)
            gb_pred = gb_model.predict(X_test_scaled)
            gb_score = f1_score(y_test, gb_pred)
            models['gradientboosting'] = gb_model
            model_scores['gradientboosting'] = gb_score

            # 앙상블 가중치 계산 (성능 기반)
            total_score = sum(model_scores.values())
            ensemble_weights = {name: score/total_score for name, score in model_scores.values()}

            # 앙상블 예측
            ensemble_pred_proba = np.zeros((len(X_test_scaled), 2))
            for name, model in models.items():
                weight = ensemble_weights[name]
                pred_proba = model.predict_proba(X_test_scaled)
                ensemble_pred_proba += weight * pred_proba

            ensemble_pred = (ensemble_pred_proba[:, 1] > 0.5).astype(int)
            ensemble_score = f1_score(y_test, ensemble_pred)

            # 백테스팅 성능 계산
            backtest_results = self.calculate_backtest_performance(
                X_test, y_test, ensemble_pred_proba[:, 1], df.iloc[split_idx:-10]
            )

            print(f"모델 성능 (F1 Score):")
            for name, score in model_scores.items():
                print(f"  {name}: {score:.3f}")
            print(f"  앙상블: {ensemble_score:.3f}")
            print(f"백테스팅 성과:")
            print(f"  총 수익률: {backtest_results['total_return']:.2%}")
            print(f"  승률: {backtest_results['win_rate']:.2%}")
            print(f"  샤프 비율: {backtest_results['sharpe_ratio']:.3f}")
            print(f"  최대 낙폭: {backtest_results['max_drawdown']:.2%}")

            # 앙상블 모델 래퍼 클래스
            class EnsembleModel:
                def __init__(self, models, weights, scaler, feature_columns):
                    self.models = models
                    self.weights = weights
                    self.scaler = scaler
                    self.feature_columns = feature_columns

                def predict(self, X):
                    X_scaled = self.scaler.transform(X[self.feature_columns])
                    ensemble_pred = np.zeros(len(X_scaled))
                    
                    for name, model in self.models.items():
                        weight = self.weights[name]
                        pred_proba = model.predict_proba(X_scaled)
                        ensemble_pred += weight * pred_proba[:, 1]
                    
                    return (ensemble_pred > 0.5).astype(int)

                def predict_proba(self, X):
                    X_scaled = self.scaler.transform(X[self.feature_columns])
                    ensemble_pred_proba = np.zeros((len(X_scaled), 2))
                    
                    for name, model in self.models.items():
                        weight = self.weights[name]
                        pred_proba = model.predict_proba(X_scaled)
                        ensemble_pred_proba += weight * pred_proba
                    
                    return ensemble_pred_proba

            ensemble_model = EnsembleModel(models, ensemble_weights, scaler, feature_columns)

            return ensemble_model, backtest_results, ensemble_score

        except Exception as e:
            print(f"앙상블 모델 훈련 오류: {e}")
            return None, None, 0.5

    def calculate_backtest_performance(self, X_test, y_test, pred_proba, price_data):
        """백테스팅 성과 계산"""
        try:
            # 매수 신호 생성 (확률 > 0.7)
            buy_signals = pred_proba > 0.7
            
            if not any(buy_signals):
                return {
                    'total_return': 0,
                    'win_rate': 0,
                    'sharpe_ratio': 0,
                    'max_drawdown': 0,
                    'trades': 0
                }

            # 거래 시뮬레이션
            capital = self.initial_capital
            portfolio_values = [capital]
            trades = []
            positions = {}

            for i, (buy_signal, actual_target) in enumerate(zip(buy_signals, y_test)):
                if buy_signal and i < len(price_data):
                    # 매수
                    entry_price = price_data.iloc[i]['Close']
                    
                    # 3일 후 매도 (타겟 기간)
                    if i + 3 < len(price_data):
                        exit_price = price_data.iloc[i + 3]['Close']
                        
                        # 거래비용 계산
                        buy_cost = entry_price * (1 + self.commission_rate + self.slippage_rate)
                        sell_revenue = exit_price * (1 - self.commission_rate - self.tax_rate - self.slippage_rate)
                        
                        trade_return = (sell_revenue - buy_cost) / buy_cost
                        
                        # 포지션 크기 (균등 분할)
                        position_size = capital * 0.1  # 10% 할당
                        trade_pnl = position_size * trade_return
                        
                        capital += trade_pnl
                        portfolio_values.append(capital)
                        
                        trades.append({
                            'entry_price': entry_price,
                            'exit_price': exit_price,
                            'return': trade_return,
                            'pnl': trade_pnl,
                            'win': trade_return > 0,
                            'actual_target': actual_target
                        })

            if not trades:
                return {
                    'total_return': 0,
                    'win_rate': 0,
                    'sharpe_ratio': 0,
                    'max_drawdown': 0,
                    'trades': 0
                }

            # 성과 지표 계산
            total_return = (capital - self.initial_capital) / self.initial_capital
            win_rate = sum(1 for t in trades if t['win']) / len(trades)
            
            # 샤프 비율
            if len(portfolio_values) > 1:
                returns = np.diff(portfolio_values) / portfolio_values[:-1]
                sharpe_ratio = np.mean(returns) / (np.std(returns) + 1e-10) * np.sqrt(252)
            else:
                sharpe_ratio = 0

            # 최대 낙폭
            peak = np.maximum.accumulate(portfolio_values)
            drawdown = (portfolio_values - peak) / peak
            max_drawdown = np.min(drawdown)

            return {
                'total_return': total_return,
                'win_rate': win_rate,
                'sharpe_ratio': sharpe_ratio,
                'max_drawdown': abs(max_drawdown),
                'trades': len(trades),
                'avg_return_per_trade': np.mean([t['return'] for t in trades]),
                'prediction_accuracy': sum(1 for t in trades if t['actual_target'] == t['win']) / len(trades)
            }

        except Exception as e:
            print(f"백테스팅 계산 오류: {e}")
            return {
                'total_return': 0,
                'win_rate': 0,
                'sharpe_ratio': 0,
                'max_drawdown': 0,
                'trades': 0
            }

    def analyze_single_stock(self, code, company):
        """단일 종목 분석 (백테스팅 포함)"""
        try:
            df = self.download_stock_data(code, company)
            if df is None or len(df) < 300:  # 최소 300일 데이터
                return None

            # 거래량 필터
            avg_volume = df['Volume'].mean()
            if avg_volume < 10000:  # 최소 거래량 기준 상향
                return None

            df = self.calculate_advanced_features(df)
            if df is None:
                return None

            model, backtest_results, model_score = self.train_ensemble_models(df)
            if model_score < 0.6:  # 기준 상향 (60%)
                return None

            # 백테스팅 성과 필터
            if (backtest_results['total_return'] < 0.05 or  # 최소 5% 수익
                backtest_results['win_rate'] < 0.55 or      # 최소 55% 승률
                backtest_results['trades'] < 5):            # 최소 5회 거래
                return None

            # 현재 예측
            feature_columns = model.feature_columns
            latest = df[feature_columns].iloc[-1:].fillna(0)

            prediction = model.predict(latest)[0]
            proba = model.predict_proba(latest)[0]
            confidence = proba[1] if prediction == 1 else proba[0]

            current_price = df['Close'].iloc[-1]

            # 엄격한 신호 판정
            if (prediction == 1 and 
                confidence > 0.8 and 
                model_score > 0.65 and
                backtest_results['total_return'] > 0.1 and
                backtest_results['win_rate'] > 0.6):
                signal = '강력매수'
            elif (prediction == 1 and 
                  confidence > 0.7 and 
                  model_score > 0.6 and
                  backtest_results['total_return'] > 0.05):
                signal = '매수'
            elif prediction == 0 and confidence > 0.75:
                signal = '매도'
            else:
                signal = '관망'

            latest_data = df.iloc[-1]

            result = {
                'code': code,
                'company': company,
                'current_price': current_price,
                'prediction': prediction,
                'confidence': confidence,
                'model_score': model_score,
                'signal': signal,
                
                # 백테스팅 성과
                'backtest_return': backtest_results['total_return'],
                'backtest_winrate': backtest_results['win_rate'],
                'backtest_sharpe': backtest_results['sharpe_ratio'],
                'backtest_mdd': backtest_results['max_drawdown'],
                'backtest_trades': backtest_results['trades'],
                'prediction_accuracy': backtest_results.get('prediction_accuracy', 0),
                
                # 기술적 지표
                'rsi_14': latest_data.get('RSI_14', 50),
                'momentum_score': latest_data.get('Momentum_Score', 0.5),
                'volume_ratio_10': latest_data.get('Volume_Ratio_10', 1),
                'bb_position_20': latest_data.get('BB_Position_20', 0.5),
                'ma_ratio_20': latest_data.get('MA_Ratio_20', 1),
                
                'avg_volume': avg_volume,
                'target_price': current_price * 1.08 if '매수' in signal else None,
                'stop_loss': current_price * 0.92 if '매수' in signal else None,
                'data_source': 'ensemble_ml_backtested'
            }

            return result

        except Exception as e:
            print(f"종목 분석 오류 ({code}): {e}")
            return None

    def process_stock_batch(self, stock_batch):
        """배치 처리"""
        batch_results = []
        for code, company in stock_batch:
            try:
                result = self.analyze_single_stock(code, company)
                if result:
                    batch_results.append(result)
                    with self.lock:
                        backtest_info = f"수익률:{result['backtest_return']:.1%} 승률:{result['backtest_winrate']:.1%}"
                        print(f"완료 {code} {company[:10]:10s} - {result['signal']} (신뢰도:{result['confidence']:.0%}, {backtest_info})")
            except Exception as e:
                continue
        return batch_results

    def run_advanced_analysis(self):
        """고급 분석 실행 (백테스팅 포함)"""
        start_time = time.time()

        print("KRX 고급 백테스팅 분석 시작!")
        print("실제 투자 성과 검증을 통한 고정밀 예측")
        print("="*80)

        total_stocks = len(self.krx_stocks)
        print(f"전체 대상 종목: {total_stocks:,}개")
        print(f"CPU 코어: {self.cpu_count}개")
        print("XGBoost + LightGBM + RandomForest 앙상블" + (" + CatBoost" if HAS_CATBOOST else ""))
        print("백테스팅 기반 실제 성과 검증")

        # 배치 설정 (속도 최적화)
        batch_size = 50  # 15 → 50으로 증가
        max_workers = min(4, self.cpu_count)  # 2 → 4로 증가

        print(f"배치 크기: {batch_size}")
        print(f"워커 수: {max_workers}")

        results = []
        processed_count = 0
        success_count = 0

        # 배치 나누기
        batches = [self.krx_stocks[i:i+batch_size]
                  for i in range(0, total_stocks, batch_size)]
        total_batches = len(batches)

        print(f"\n분석 시작... (총 {total_batches:,}개 배치)")
        print("-" * 80)

        # 진행률 표시
        try:
            progress_bar = tqdm(total=total_batches, desc="종목 처리",
                              bar_format="{l_bar}{bar}| {n_fmt}/{total_fmt} [{elapsed}<{remaining}]")
        except:
            progress_bar = None

        # 멀티스레딩 실행
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_batch = {
                executor.submit(self.process_stock_batch, batch): i
                for i, batch in enumerate(batches)
            }

            for future in as_completed(future_to_batch):
                batch_results = future.result()

                if batch_results:
                    results.extend(batch_results)
                    success_count += len(batch_results)

                processed_count += 1

                if progress_bar:
                    progress_bar.update(1)

                # 중간 상황 보고
                if processed_count % 5 == 0 or processed_count == total_batches:
                    elapsed = time.time() - start_time
                    processed_stocks = processed_count * batch_size

                    if elapsed > 0:
                        success_rate = success_count / processed_stocks * 100 if processed_stocks > 0 else 0

                        print(f"\n중간 현황 ({processed_count:,}/{total_batches:,} 배치)")
                        print(f"   경과: {elapsed/60:.1f}분")
                        print(f"   처리: {processed_stocks:,}/{total_stocks:,} 종목")
                        print(f"   성공: {success_count:,}개 | 성공률: {success_rate:.1f}%")

                        # 현재까지 매수 신호
                        if results:
                            current_df = pd.DataFrame(results)
                            buy_count = len(current_df[current_df['signal'].isin(['매수', '강력매수'])])
                            premium_count = len(current_df[current_df['signal'] == '강력매수'])
                            avg_backtest_return = current_df['backtest_return'].mean()
                            avg_winrate = current_df['backtest_winrate'].mean()
                            print(f"   매수 신호: {buy_count:,}개 | 강력매수: {premium_count:,}개")
                            print(f"   평균 백테스트 수익률: {avg_backtest_return:.1%} | 평균 승률: {avg_winrate:.1%}")

                # 메모리 정리
                if processed_count % 10 == 0:
                    gc.collect()

        if progress_bar:
            progress_bar.close()

        # 최종 결과 정리
        total_time = time.time() - start_time

        if not results:
            print("\n분석 결과가 없습니다.")
            return None

        print(f"\nKRX 고급 백테스팅 분석 완료!")
        print("="*80)

        # 결과 DataFrame 생성
        df_results = pd.DataFrame(results)

        # 엄격한 매수 신호 필터링
        buy_signals = df_results[
            (df_results['signal'].isin(['매수', '강력매수'])) &
            (df_results['confidence'] > 0.7) &
            (df_results['model_score'] > 0.6) &
            (df_results['backtest_return'] > 0.05) &
            (df_results['backtest_winrate'] > 0.55)
        ].copy()

        # 프리미엄 매수 신호 (더 엄격한 기준)
        premium_signals = df_results[
            (df_results['signal'] == '강력매수') &
            (df_results['confidence'] > 0.8) &
            (df_results['model_score'] > 0.65) &
            (df_results['backtest_return'] > 0.1) &
            (df_results['backtest_winrate'] > 0.6) &
            (df_results['backtest_sharpe'] > 1.0)
        ].copy()

        # 매도 신호
        sell_signals = df_results[
            (df_results['signal'] == '매도') &
            (df_results['confidence'] > 0.75)
        ].copy()

        # 백테스팅 성과순 정렬
        buy_signals = buy_signals.sort_values(['backtest_return', 'backtest_winrate', 'confidence'], ascending=False)
        premium_signals = premium_signals.sort_values(['backtest_return', 'backtest_winrate', 'confidence'], ascending=False)
        sell_signals = sell_signals.sort_values(['confidence', 'model_score'], ascending=False)

        # 성능 통계
        avg_model_score = df_results['model_score'].mean()
        avg_confidence = df_results['confidence'].mean()
        avg_backtest_return = df_results['backtest_return'].mean()
        avg_winrate = df_results['backtest_winrate'].mean()
        avg_prediction_accuracy = df_results['prediction_accuracy'].mean()
        success_rate = len(results) / total_stocks * 100

        # 최종 결과 출력
        print(f"총 소요시간: {total_time/60:.1f}분")
        print(f"전체 대상: {total_stocks:,}개 종목")
        print(f"분석 성공: {len(results):,}개 종목")
        print(f"전체 성공률: {success_rate:.1f}%")
        print(f"yfinance 성공: {len(self.successful_downloads):,}개")
        print(f"다운로드 실패: {len(self.failed_downloads):,}개")
        print()
        print("=== 모델 성능 지표 ===")
        print(f"평균 모델 점수: {avg_model_score:.1%}")
        print(f"평균 신뢰도: {avg_confidence:.1%}")
        print(f"평균 예측 정확도: {avg_prediction_accuracy:.1%}")
        print()
        print("=== 백테스팅 성과 ===")
        print(f"평균 백테스트 수익률: {avg_backtest_return:.1%}")
        print(f"평균 승률: {avg_winrate:.1%}")
        print()
        print("=== 투자 신호 ===")
        print(f"전체 매수 신호: {len(buy_signals):,}개")
        print(f"프리미엄 매수 신호: {len(premium_signals):,}개")
        print(f"매도 신호: {len(sell_signals):,}개")

        # 결과 출력
        if len(premium_signals) > 0:
            print(f"\n프리미엄 매수 추천 TOP {min(10, len(premium_signals))}개 (백테스팅 검증)")
            print("-"*100)
            for i, (_, row) in enumerate(premium_signals.head(10).iterrows(), 1):
                backtest_info = f"수익률:{row['backtest_return']:.1%} 승률:{row['backtest_winrate']:.1%} 샤프:{row['backtest_sharpe']:.2f}"
                print(f"{i:2d}. {row['code']} {row['company'][:15]:15s} "
                      f"{row['current_price']:8,.0f}원 → {row['target_price']:8,.0f}원 "
                      f"신뢰도:{row['confidence']:.0%} ({backtest_info})")

        if len(buy_signals) > 0:
            print(f"\n매수 추천 TOP {min(15, len(buy_signals))}개 (백테스팅 검증)")
            print("-"*100)
            for i, (_, row) in enumerate(buy_signals.head(15).iterrows(), 1):
                backtest_info = f"수익률:{row['backtest_return']:.1%} 승률:{row['backtest_winrate']:.1%}"
                print(f"{i:2d}. {row['code']} {row['company'][:15]:15s} "
                      f"{row['current_price']:8,.0f}원 → {row['target_price']:8,.0f}원 "
                      f"신뢰도:{row['confidence']:.0%} ({backtest_info})")

        # 파일 저장
        self.save_advanced_results(df_results, buy_signals, premium_signals, sell_signals)

        return df_results, buy_signals, premium_signals, sell_signals

    def save_advanced_results(self, df_results, buy_signals, premium_signals, sell_signals):
        """고급 분석 결과 저장"""
        try:
            today = datetime.now().strftime("%Y%m%d_%H%M")
            success_files = []

            print(f"\n분석 결과 저장 중...")

            # 1. 전체 결과 저장 (백테스팅 정보 포함)
            try:
                full_filename = f'krx_advanced_analysis_{today}.csv'
                full_path = os.path.join(self.save_dir, full_filename)
                df_results.to_csv(full_path, index=False, encoding='utf-8-sig')
                success_files.append(full_filename)
                print(f"전체 결과: {full_filename} ({len(df_results):,}개)")
            except Exception as e:
                print(f"전체 결과 저장 실패: {e}")

            # 2. 프리미엄 매수 신호
            if len(premium_signals) > 0:
                try:
                    premium_filename = f'krx_premium_backtested_{today}.csv'
                    premium_path = os.path.join(self.save_dir, premium_filename)
                    premium_signals.to_csv(premium_path, index=False, encoding='utf-8-sig')
                    success_files.append(premium_filename)
                    print(f"프리미엄 매수: {premium_filename} ({len(premium_signals):,}개)")
                except Exception as e:
                    print(f"프리미엄 매수 저장 실패: {e}")

            # 3. 매수 신호
            if len(buy_signals) > 0:
                try:
                    buy_filename = f'krx_buy_backtested_{today}.csv'
                    buy_path = os.path.join(self.save_dir, buy_filename)
                    buy_signals.to_csv(buy_path, index=False, encoding='utf-8-sig')
                    success_files.append(buy_filename)
                    print(f"매수 신호: {buy_filename} ({len(buy_signals):,}개)")
                except Exception as e:
                    print(f"매수 신호 저장 실패: {e}")

            # 4. 매도 신호
            if len(sell_signals) > 0:
                try:
                    sell_filename = f'krx_sell_backtested_{today}.csv'
                    sell_path = os.path.join(self.save_dir, sell_filename)
                    sell_signals.to_csv(sell_path, index=False, encoding='utf-8-sig')
                    success_files.append(sell_filename)
                    print(f"매도 신호: {sell_filename} ({len(sell_signals):,}개)")
                except Exception as e:
                    print(f"매도 신호 저장 실패: {e}")

            # 5. 고급 분석 보고서
            try:
                report_filename = f'krx_advanced_report_{today}.txt'
                report_path = os.path.join(self.save_dir, report_filename)

                with open(report_path, 'w', encoding='utf-8') as f:
                    f.write("KRX 고급 백테스팅 분석 보고서\n")
                    f.write("="*60 + "\n")
                    f.write(f"분석 날짜: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n")
                    f.write(f"분석 방식: XGBoost + LightGBM + CatBoost + RandomForest 앙상블\n")
                    f.write(f"백테스팅: 실제 투자 성과 검증 포함\n")
                    f.write(f"전체 대상 종목: {len(self.krx_stocks):,}개\n")
                    f.write(f"분석 성공 종목: {len(df_results):,}개\n")
                    f.write(f"성공률: {len(df_results)/len(self.krx_stocks)*100:.1f}%\n\n")
                    
                    f.write("=== 모델 성능 지표 ===\n")
                    f.write(f"평균 모델 점수: {df_results['model_score'].mean():.1%}\n")
                    f.write(f"평균 신뢰도: {df_results['confidence'].mean():.1%}\n")
                    f.write(f"평균 예측 정확도: {df_results['prediction_accuracy'].mean():.1%}\n\n")
                    
                    f.write("=== 백테스팅 성과 ===\n")
                    f.write(f"평균 백테스트 수익률: {df_results['backtest_return'].mean():.1%}\n")
                    f.write(f"평균 승률: {df_results['backtest_winrate'].mean():.1%}\n")
                    f.write(f"평균 샤프 비율: {df_results['backtest_sharpe'].mean():.2f}\n")
                    f.write(f"평균 최대 낙폭: {df_results['backtest_mdd'].mean():.1%}\n\n")
                    
                    f.write("=== 투자 신호 ===\n")
                    f.write(f"매수 신호: {len(buy_signals):,}개\n")
                    f.write(f"프리미엄 매수: {len(premium_signals):,}개\n")
                    f.write(f"매도 신호: {len(sell_signals):,}개\n\n")

                    f.write("투자 유의사항:\n")
                    f.write("- 본 분석은 백테스팅을 통해 검증되었으나 투자 조언이 아닙니다\n")
                    f.write("- 과거 성과가 미래 수익을 보장하지 않습니다\n")
                    f.write("- 투자 결정은 본인 책임하에 이루어져야 합니다\n")
                    f.write("- 충분한 리스크 관리와 분산투자를 권장합니다\n")
                    f.write("- 백테스팅 결과는 거래비용과 세금을 반영했습니다\n\n")

                    if len(premium_signals) > 0:
                        f.write(f"프리미엄 매수 추천 TOP 10 (백테스팅 검증):\n")
                        f.write("-"*70 + "\n")
                        for i, (_, row) in enumerate(premium_signals.head(10).iterrows(), 1):
                            f.write(f"{i:2d}. {row['code']} {row['company'][:15]:15s} ")
                            f.write(f"{row['current_price']:8,.0f}원 신뢰도:{row['confidence']:.0%}\n")
                            f.write(f"    백테스트 수익률:{row['backtest_return']:.1%} ")
                            f.write(f"승률:{row['backtest_winrate']:.1%} 샤프:{row['backtest_sharpe']:.2f}\n")

                    if len(buy_signals) > 0:
                        f.write(f"\n매수 추천 TOP 15 (백테스팅 검증):\n")
                        f.write("-"*70 + "\n")
                        for i, (_, row) in enumerate(buy_signals.head(15).iterrows(), 1):
                            f.write(f"{i:2d}. {row['code']} {row['company'][:15]:15s} ")
                            f.write(f"{row['current_price']:8,.0f}원 신뢰도:{row['confidence']:.0%}\n")
                            f.write(f"    백테스트 수익률:{row['backtest_return']:.1%} ")
                            f.write(f"승률:{row['backtest_winrate']:.1%}\n")

                success_files.append(report_filename)
                print(f"분석 보고서: {report_filename}")

            except Exception as e:
                print(f"분석 보고서 저장 실패: {e}")

            # 6. 백테스팅 성과 요약
            try:
                backtest_filename = f'krx_backtest_summary_{today}.txt'
                backtest_path = os.path.join(self.save_dir, backtest_filename)

                with open(backtest_path, 'w', encoding='utf-8') as f:
                    f.write("백테스팅 성과 요약\n")
                    f.write("="*50 + "\n\n")
                    
                    if len(buy_signals) > 0:
                        top_performers = buy_signals.head(10)
                        
                        f.write("TOP 10 종목 백테스팅 성과:\n")
                        f.write("-"*50 + "\n")
                        
                        for i, (_, row) in enumerate(top_performers.iterrows(), 1):
                            f.write(f"{i:2d}. {row['code']} {row['company']}\n")
                            f.write(f"    현재가: {row['current_price']:,.0f}원\n")
                            f.write(f"    백테스트 수익률: {row['backtest_return']:.2%}\n")
                            f.write(f"    승률: {row['backtest_winrate']:.1%}\n")
                            f.write(f"    샤프 비율: {row['backtest_sharpe']:.3f}\n")
                            f.write(f"    최대 낙폭: {row['backtest_mdd']:.1%}\n")
                            f.write(f"    거래 횟수: {row['backtest_trades']}\n")
                            f.write(f"    예측 정확도: {row['prediction_accuracy']:.1%}\n")
                            f.write(f"    신뢰도: {row['confidence']:.1%}\n\n")
                        
                        # 전체 통계
                        f.write("전체 매수 신호 통계:\n")
                        f.write("-"*30 + "\n")
                        f.write(f"총 종목 수: {len(buy_signals)}개\n")
                        f.write(f"평균 백테스트 수익률: {buy_signals['backtest_return'].mean():.2%}\n")
                        f.write(f"평균 승률: {buy_signals['backtest_winrate'].mean():.1%}\n")
                        f.write(f"평균 샤프 비율: {buy_signals['backtest_sharpe'].mean():.3f}\n")
                        f.write(f"평균 최대 낙폭: {buy_signals['backtest_mdd'].mean():.1%}\n")
                        f.write(f"평균 예측 정확도: {buy_signals['prediction_accuracy'].mean():.1%}\n")
                        
                        # 수익률 분포
                        high_return = len(buy_signals[buy_signals['backtest_return'] > 0.15])
                        medium_return = len(buy_signals[(buy_signals['backtest_return'] > 0.05) & (buy_signals['backtest_return'] <= 0.15)])
                        low_return = len(buy_signals[buy_signals['backtest_return'] <= 0.05])
                        
                        f.write(f"\n수익률 분포:\n")
                        f.write(f"고수익 (15% 이상): {high_return}개 ({high_return/len(buy_signals)*100:.1f}%)\n")
                        f.write(f"중수익 (5-15%): {medium_return}개 ({medium_return/len(buy_signals)*100:.1f}%)\n")
                        f.write(f"저수익 (5% 이하): {low_return}개 ({low_return/len(buy_signals)*100:.1f}%)\n")

                success_files.append(backtest_filename)
                print(f"백테스팅 요약: {backtest_filename}")

            except Exception as e:
                print(f"백테스팅 요약 저장 실패: {e}")

            # 저장 결과 확인
            if success_files:
                print(f"\n저장된 파일:")
                for filename in success_files:
                    full_path = os.path.join(self.save_dir, filename)
                    if os.path.exists(full_path):
                        size = os.path.getsize(full_path) / 1024
                        print(f"  {filename} ({size:.1f}KB)")

            return len(success_files) > 0

        except Exception as e:
            print(f"저장 프로세스 오류: {e}")
            return False

# ================================================================
# 실행부
# ================================================================

def show_advanced_disclaimer():
    print("="*80)
    print("고급 백테스팅 분석 면책조항")
    print("="*80)
    print("1. 본 분석은 머신러닝과 백테스팅을 통한 참고 자료입니다")
    print("2. 백테스팅 결과가 미래 수익을 보장하지 않습니다")
    print("3. 실제 거래비용, 세금, 슬리피지가 반영되었습니다")
    print("4. 투자 결정은 본인 책임하에 이루어져야 합니다")
    print("5. 충분한 리스크 관리와 분산투자를 권장합니다")
    print("6. 과거 성과는 미래 성과를 나타내지 않습니다")
    print("="*80)

if __name__ == "__main__":
    print("KRX 고급 백테스팅 분석기 시작!")
    print("XGBoost + 앙상블 + 실제 투자 성과 검증")
    print("="*80)

    # 면책 조항 표시
    show_advanced_disclaimer()

    try:
        # 분석기 초기화
        print(f"\n고급 시스템 초기화 중...")
        analyzer = AdvancedKRXBacktester()

        print(f"\n시스템 준비 완료!")
        print(f"   CPU: {analyzer.cpu_count}코어")
        print(f"   대상 종목: {len(analyzer.krx_stocks):,}개")
        print(f"   앙상블 모델: XGBoost + LightGBM + RandomForest" + (" + CatBoost" if HAS_CATBOOST else ""))
        print(f"   백테스팅: 실제 거래비용 반영")
        print(f"   하이퍼파라미터 최적화: Optuna")

        # 실행 확인
        print(f"\n주의사항:")
        print(f"   - 예상 소요시간: 30-90분 (고급 분석)")
        print(f"   - 메모리 사용량: 높음")
        print(f"   - 백테스팅 포함으로 시간 소요")

        user_input = input(f"\n고급 백테스팅 분석을 진행하시겠습니까? (y/n): ").lower()
        if user_input != 'y':
            print("분석을 취소했습니다.")
            exit()

        # 고급 분석 실행
        results = analyzer.run_advanced_analysis()

        if results and len(results) == 4:
            df_results, buy_signals, premium_signals, sell_signals = results

            print(f"\nKRX 고급 백테스팅 분석 완료!")
            print(f"실제 투자 성과가 검증된 고정밀 예측 완료!")

            # 최종 요약
            print(f"\n=== 최종 분석 결과 ===")
            print(f"전체 대상: {len(analyzer.krx_stocks):,}개 종목")
            print(f"분석 성공: {len(df_results):,}개 종목")
            print(f"매수 신호: {len(buy_signals):,}개 종목")
            print(f"프리미엄 매수: {len(premium_signals):,}개 종목")
            print(f"매도 신호: {len(sell_signals):,}개 종목")

            print(f"\n=== 백테스팅 성과 ===")
            if len(buy_signals) > 0:
                print(f"평균 백테스트 수익률: {buy_signals['backtest_return'].mean():.1%}")
                print(f"평균 승률: {buy_signals['backtest_winrate'].mean():.1%}")
                print(f"평균 샤프 비율: {buy_signals['backtest_sharpe'].mean():.2f}")
                print(f"평균 예측 정확도: {buy_signals['prediction_accuracy'].mean():.1%}")

            if len(premium_signals) > 0:
                print(f"\n발굴된 프리미엄 종목 TOP 3 (백테스팅 검증):")
                for i, (_, row) in enumerate(premium_signals.head(3).iterrows(), 1):
                    print(f"   {i}. {row['code']} {row['company'][:15]:15s} "
                          f"(백테스트 수익률:{row['backtest_return']:.1%}, "
                          f"승률:{row['backtest_winrate']:.1%})")

            print(f"\n모든 결과가 CSV 파일로 저장되었습니다.")
            print(f"백테스팅 성과가 포함된 상세한 분석 보고서를 확인하세요.")

        else:
            print("분석 결과가 없습니다.")
            print("네트워크 연결이나 시장 상황을 확인해보세요.")

    except KeyboardInterrupt:
        print("\n사용자 중단")
        print("분석이 중단되었습니다.")
    except Exception as e:
        print(f"\n오류 발생: {e}")
        import traceback
        traceback.print_exc()

print("\nKRX 고급 백테스팅 분석기 종료!")
